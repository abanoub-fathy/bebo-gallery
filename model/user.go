package model

import (
	"errors"
	"net/mail"
	"os"
	"strings"

	"github.com/abanoub-fathy/bebo-gallery/hash"
	"github.com/abanoub-fathy/bebo-gallery/rand"
	uuid "github.com/satori/go.uuid"
	"golang.org/x/crypto/bcrypt"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

var (
	// ErrNotFound is returned when the resource can not be found from DB
	ErrNotFound = errors.New("model: resource not found")

	// ErrNotValidEmail is returned when the email address is invalid email
	ErrNotValidEmail = errors.New("model: email address not valid")

	// ErrPasswordNotCorrect is returned when the password is wrong for user
	ErrPasswordNotCorrect = errors.New("model: password is incorrect")
)

// UserDB is used to interact with the users database.
//
// For pretty much all single user queries:
// If the user is found, we will return a nil error
// If the user is not found, we will return ErrNotFound
// If there is another error, we will return an error with
// more information about what went wrong. This may not be
// an error generated by the models package.
//
// For single user queries, any error but ErrNotFound should
// probably result in a 500 error until we make "public"
// facing errors.
type UserDB interface {
	// Methods for querying for single users
	FindByID(ID string) (*User, error)
	FindByEmail(email string) (*User, error)
	FindUserByRememberToken(token string) (*User, error)

	// Methods for altering users
	CreateUser(user *User) error
	FindAndUpdateByID(userID string, updates map[string]interface{}) (*User, error)
	FindAndDeleteByID(userID string) (*User, error)
	Save(user *User) error
	SetNewRemeberToken(user *User) error

	// Used to close a DB connection
	Close() error

	// Migration helpers
	AutoMigrate() error
	ResetUserDB() error
}

// userGorm represents our database interaction layer
// and implements the UserDB interface fully.
type userGorm struct {
	db     *gorm.DB
	hasher *hash.Hasher
}

// newUserService creates a new userService to
// interact with users
func newUserGorm(DB_URI string) (*userGorm, error) {
	// connect to DB
	db, err := gorm.Open(postgres.Open(DB_URI), &gorm.Config{})
	if err != nil {
		return nil, err
	}

	// return userService
	return &userGorm{
		db:     db,
		hasher: hash.NewHasher(os.Getenv("HASH_SECRET_KEY")),
	}, nil
}

var _ UserDB = &userGorm{}

type User struct {
	Base
	FirstName        string `gorm:"not null"`
	LastName         string `gorm:"not null"`
	Email            string `gorm:"not null;unique;index"`
	Password         string `gorm:"-"`
	PasswordHash     string `gorm:"not null"`
	RememberToken    string `gorm:"-"`
	RemeberTokenHash string `gorm:"unique;index"`
}

// UserService is an interface that contains
// smethods to interact with user model
type UserService interface {
	// AuthenticateUser is used to check the user email vs password
	// if it is correct you will get the user and nil error
	// otherwise you will get an error
	//
	// error can be ErrNotValidEmail, ErrNotFound, ErrPasswordNotCorrect
	// or other generic error during authenticate user
	AuthenticateUser(email, password string) (*User, error)

	UserDB
}

type userService struct {
	UserDB
}

// NewUserService creates a new userService to
// interact with users
func NewUserService(DB_URI string) (UserService, error) {
	// create new userGorm
	userGorm, err := newUserGorm(DB_URI)
	if err != nil {
		return nil, err
	}

	// set the userGorm to UserDB in the UserService
	userService := &userService{
		UserDB: userGorm,
	}

	// return
	return userService, nil
}

// CreateUser is used to create new user in our database
//
// the method also will generate token to the new user and
// save it to the database
func (ug *userGorm) CreateUser(user *User) error {
	if user.Password == "" {
		return errors.New("user password is required")
	}

	// hash the user password
	password, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
	if err != nil {
		return err
	}
	user.PasswordHash = string(password)
	user.Password = ""

	// set new remember token
	ug.SetNewRemeberToken(user)

	// save user in the database
	return ug.db.Create(&user).Error
}

// SetNewRemeberToken is used to generate and set new remember token
// for the given user in the argument
//
// the method will not save the hash of the token to the database
//
// if there is no error the method will return nil error
func (ug *userGorm) SetNewRemeberToken(user *User) error {
	// generate new random remember token
	token, err := rand.GenerateRememberToken()
	if err != nil {
		return err
	}

	// hash the token
	hashedToken := ug.hasher.HashByHMAC(token)

	// set user token
	user.RememberToken = token
	user.RemeberTokenHash = hashedToken

	// return no error
	return nil
}

// FindByID is used to find user by its id
// it will return the user from db and error if there is an error
// if there is no user found it will return error of type ErrNotFound
func (ug *userGorm) FindByID(ID string) (*User, error) {
	// define the user
	user := new(User)

	// fetch user by id from db
	query := ug.db.Where(User{
		Base: Base{
			ID: uuid.FromStringOrNil(ID),
		},
	})

	// get user record
	err := getRecord(query, &user)

	// return result
	return user, err
}

// FindByEmail is used to find user by its email address
// it will return the user from db and error if there is an error
// if there is no user found it will return error of type ErrNotFound
func (ug *userGorm) FindByEmail(email string) (*User, error) {
	user := new(User)
	query := ug.db.Where(&User{
		Email: email,
	})
	err := getRecord(query, user)
	return user, err
}

func getRecord(query *gorm.DB, destination interface{}) error {
	switch err := query.First(destination).Error; err {
	case nil:
		return nil
	case gorm.ErrRecordNotFound:
		destination = nil
		return ErrNotFound
	default:
		destination = nil
		return err
	}
}

// FindAndDeleteByID is used to delete user by its id
//
// it will first find the user and then delete it
//
// if the user is not found it will return ErrNotFound
//
// it returns the deleted user and the error if existed
func (ug *userGorm) FindAndDeleteByID(userID string) (*User, error) {
	user, err := ug.FindByID(userID)
	if err != nil {
		return nil, err
	}
	err = ug.db.Delete(&user).Error
	if err != nil {
		return nil, err
	}

	return user, nil
}

// FindAndUpdateByID is used to update user by its id
// it will return the error if there is something wrong while updating user
//
// if the user is updated correctly it will return the updated user and nil error
//
// if there is no user found it will return error of type ErrNotFound
func (ug *userGorm) FindAndUpdateByID(userID string, updates map[string]interface{}) (*User, error) {
	user, err := ug.FindByID(userID)
	if err != nil {
		return nil, err
	}
	err = ug.db.Model(&user).Updates(updates).Error
	if err != nil {
		return nil, err
	}
	return user, err
}

// Save is used to update existing user
func (ug *userGorm) Save(user *User) error {
	return ug.db.Save(&user).Error
}

// AuthenticateUser is used to return user by email and password
//
// if the user is found the method will return the user object and nil error
func (userService *userService) AuthenticateUser(email, password string) (*User, error) {
	// trim and lowerspace email
	email = strings.ToLower(strings.TrimSpace(email))

	// check if the email is valid
	_, err := mail.ParseAddress(email)
	if err != nil {
		return nil, ErrNotValidEmail
	}

	// find user by email
	user, err := userService.FindByEmail(email)
	if err != nil {
		return nil, err
	}

	// compare user password
	err = bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password))
	if err != nil {
		switch err {
		case bcrypt.ErrMismatchedHashAndPassword:
			return nil, ErrPasswordNotCorrect
		default:
			return nil, err
		}
	}

	// return the user and nil error
	return user, nil
}

// FindUserByRememberToken is used to find user by remember token
func (ug *userGorm) FindUserByRememberToken(token string) (*User, error) {
	// define user
	user := new(User)

	// hash the token
	hashedToken := ug.hasher.HashByHMAC(token)

	// make query
	query := ug.db.Where(&User{
		RemeberTokenHash: hashedToken,
	})
	// get the user
	err := getRecord(query, user)
	// return user
	return user, err
}

// Close used to close userService database connection
func (ug *userGorm) Close() error {
	sqlDB, err := ug.db.DB()
	if err != nil {
		return err
	}
	if err := sqlDB.Close(); err != nil {
		return err
	}
	return nil
}

// AutoMigrate is used to auto migrate user table into the database
func (ug *userGorm) AutoMigrate() error {
	return ug.db.AutoMigrate(&User{})
}

// ResetUserDB is used to drop user table and create new one
func (ug *userGorm) ResetUserDB() error {
	if err := ug.db.Migrator().DropTable(&User{}); err != nil {
		return err
	}

	// auto migrate user
	return ug.AutoMigrate()
}
